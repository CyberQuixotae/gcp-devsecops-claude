# GCP Security Engineering Configuration for SMB
# Production-ready Terraform configuration with comprehensive security controls
# Optimized for small-to-medium businesses with cost considerations

# Originally generated by Claude 4 Sonnet, with modifications by cyberquixote

terraform {
  required_version = ">= 1.0"
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
    google-beta = {
      source  = "hashicorp/google-beta"
      version = "~> 5.0"
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.1"
    }
  }

  # Recommended: Use remote state
  backend "gcs" {
    # Configure in backend.tf or via terraform init
    # bucket = "your-terraform-state-bucket"
    # prefix = "security/terraform.tfstate"
  }
}

# Local values for resource naming and common tags
locals {
  resource_prefix = "${lower(var.company_name)}-${var.environment}"
  common_labels = {
    environment     = var.environment
    managed_by     = "terraform"
    security_level = "high"
    company        = var.company_name
    project        = var.project_id
  }
}

# Data sources
data "google_client_config" "current" {}

data "google_project" "current" {
  project_id = var.project_id
}

# Provider configuration
provider "google" {
  project = var.project_id
  region  = var.region
  zone    = var.zone
}

provider "google-beta" {
  project = var.project_id
  region  = var.region
  zone    = var.zone
}

# Random password for demonstration
resource "random_password" "db_password" {
  length  = 32
  special = true
}

# Enable required APIs
resource "google_project_service" "security_apis" {
  for_each = toset([
    "cloudresourcemanager.googleapis.com",
    "iam.googleapis.com",
    "cloudasset.googleapis.com",
    "securitycenter.googleapis.com",
    "logging.googleapis.com",
    "monitoring.googleapis.com",
    "cloudkms.googleapis.com",
    "secretmanager.googleapis.com",
    "binaryauthorization.googleapis.com",
    "containeranalysis.googleapis.com",
    "cloudtrace.googleapis.com",
    "compute.googleapis.com",
    "container.googleapis.com",
    "dns.googleapis.com",
    "storage-api.googleapis.com",
    "oslogin.googleapis.com",
    "accesscontextmanager.googleapis.com"
  ])

  project = var.project_id
  service = each.value

  timeouts {
    create = "30m"
    update = "40m"
  }

  disable_dependent_services = false
  disable_on_destroy         = false
}

# Wait for APIs to be enabled
resource "time_sleep" "wait_for_apis" {
  depends_on = [google_project_service.security_apis]
  create_duration = "60s"
}

# Security Command Center (Optional - Premium feature)
resource "google_security_center_organization_custom_module" "security_module" {
  count = var.enable_security_center ? 1 : 0

  organization = var.organization_id
  display_name = "${var.company_name} Custom Security Module"

  enablement_state = "ENABLED"

  custom_config {
    predicate {
      expression = "resource.type == \"gce_instance\" && resource.data.status == \"RUNNING\""
    }

    custom_output {
      properties {
        name = "instance_name"
        value_expression {
          expression = "resource.data.name"
        }
      }
    }

    description    = "Custom security module for ${var.company_name}"
    recommendation = "Review running instances for security compliance"
    severity       = "MEDIUM"
  }

  depends_on = [time_sleep.wait_for_apis]
}

# Cloud KMS for encryption
resource "google_kms_key_ring" "security_keyring" {
  name       = "${local.resource_prefix}-security-keyring"
  location   = var.region
  depends_on = [time_sleep.wait_for_apis]
}

resource "google_kms_crypto_key" "security_key" {
  name            = "${local.resource_prefix}-security-key"
  key_ring        = google_kms_key_ring.security_keyring.id
  rotation_period = var.kms_rotation_period

  version_template {
    algorithm = "GOOGLE_SYMMETRIC_ENCRYPTION"
  }

  labels = local.common_labels

  lifecycle {
    prevent_destroy = true
  }
}

# IAM Security Configuration
resource "google_project_iam_custom_role" "security_admin" {
  role_id     = "${var.company_name}SecurityAdmin"
  title       = "${var.company_name} Security Administrator"
  description = "Custom role for security administration"
  permissions = [
    "securitycenter.assets.list",
    "securitycenter.findings.list",
    "securitycenter.sources.list",
    "logging.logs.list",
    "logging.entries.list",
    "monitoring.alertPolicies.list",
    "monitoring.notificationChannels.list",
    "iam.serviceAccounts.list",
    "iam.roles.list",
    "cloudkms.keyRings.list",
    "cloudkms.cryptoKeys.list",
    "compute.instances.list",
    "compute.networks.list",
    "compute.firewalls.list"
  ]

  depends_on = [time_sleep.wait_for_apis]
}

# Service Account for Security Operations
resource "google_service_account" "security_ops" {
  account_id   = "${local.resource_prefix}-security-ops"
  display_name = "${var.company_name} Security Operations"
  description  = "Service account for security operations and monitoring"

  depends_on = [time_sleep.wait_for_apis]
}

# Bind custom role to service account or group
resource "google_project_iam_member" "security_ops_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.security_admin.id
  member  = "serviceAccount:${google_service_account.security_ops.email}"
# member  = "group:{emailid}" if you decide to re-use this code for a prod environment
}

# Bind admin users to security role
resource "google_project_iam_member" "admin_security_binding" {
  for_each = toset(var.admin_users)
  project  = var.project_id
  role     = google_project_iam_custom_role.security_admin.id
  member   = "user:${each.value}"
# member  = "group:{emailid}" if you decide to re-use this code for a prod environment
}

# Storage bucket for security logs
resource "google_storage_bucket" "security_logs" {
  count = var.enable_logging ? 1 : 0

  name          = "${var.project_id}-${local.resource_prefix}-security-logs"
  location      = var.region
  force_destroy = false

  versioning {
    enabled = true
  }

  encryption {
    default_kms_key_name = google_kms_crypto_key.security_key.id
  }

  lifecycle_rule {
    condition {
      age = var.log_retention_days
    }
    action {
      type = "Delete"
    }
  }

  lifecycle_rule {
    condition {
      age = max(7, floor(var.log_retention_days / 3))
    }
    action {
      type          = "SetStorageClass"
      storage_class = "NEARLINE"
    }
  }

  uniform_bucket_level_access = true
  public_access_prevention    = "enforced"

  labels = local.common_labels

  depends_on = [time_sleep.wait_for_apis]
}

# Grant KMS access to Cloud Storage service account
data "google_storage_project_service_account" "gcs_account" {
  depends_on = [time_sleep.wait_for_apis]
}

resource "google_kms_crypto_key_iam_member" "storage_key_access" {
  count = var.enable_logging ? 1 : 0

  crypto_key_id = google_kms_crypto_key.security_key.id
  role          = "roles/cloudkms.cryptoKeyEncrypterDecrypter"
# member        = "group:{emailid}" if you decide to re-use this code with groups
  member        = "serviceAccount:${data.google_storage_project_service_account.gcs_account.email_address}"
}

# Cloud Logging Configuration
resource "google_logging_project_sink" "security_sink" {
  count = var.enable_logging ? 1 : 0

  name        = "${local.resource_prefix}-security-logs"
  destination = "storage.googleapis.com/${google_storage_bucket.security_logs[0].name}"

  filter = <<EOF
(protoPayload.serviceName="cloudresourcemanager.googleapis.com" OR
 protoPayload.serviceName="iam.googleapis.com" OR
 protoPayload.serviceName="compute.googleapis.com" OR
 protoPayload.serviceName="container.googleapis.com" OR
 protoPayload.serviceName="cloudkms.googleapis.com" OR
 protoPayload.serviceName="secretmanager.googleapis.com" OR
 severity >= ERROR OR
 protoPayload.methodName="SetIamPolicy" OR
 protoPayload.methodName="CreateServiceAccount" OR
 protoPayload.methodName="DeleteServiceAccount")
EOF

  unique_writer_identity = true
  depends_on            = [google_storage_bucket.security_logs]
}

# Grant Cloud Logging permission to write to bucket
resource "google_storage_bucket_iam_member" "security_logs_writer" {
  count = var.enable_logging ? 1 : 0

  bucket = google_storage_bucket.security_logs[0].name
  role   = "roles/storage.objectCreator"
  member = google_logging_project_sink.security_sink[0].writer_identity
}

# Cloud Monitoring Notification Channel
resource "google_monitoring_notification_channel" "email_alerts" {
  count = var.enable_monitoring ? 1 : 0

  display_name = "${var.company_name} Security Alerts"
  type         = "email"

  labels = {
    email_address = var.security_email
  }

  depends_on = [time_sleep.wait_for_apis]
}

# Monitoring Alert Policies
resource "google_monitoring_alert_policy" "iam_policy_changes" {
  count = var.enable_monitoring ? 1 : 0

  display_name = "IAM Policy Changes"
  combiner     = "OR"

  conditions {
    display_name = "IAM policy binding changes"

    condition_threshold {
      filter          = "resource.type=\"project\" AND protoPayload.methodName=\"SetIamPolicy\""
      duration        = "0s"
      comparison      = "COMPARISON_GT"
      threshold_value = 0

      aggregations {
        alignment_period   = "60s"
        per_series_aligner = "ALIGN_COUNT"
      }
    }
  }

  notification_channels = [google_monitoring_notification_channel.email_alerts[0].id]

  alert_strategy {
    auto_close = "86400s"
  }

  documentation {
    content = "Alert triggered when IAM policies are modified. Review changes immediately."
  }
}

resource "google_monitoring_alert_policy" "failed_login_attempts" {
  count = var.enable_monitoring ? 1 : 0

  display_name = "Failed Login Attempts"
  combiner     = "OR"

  conditions {
    display_name = "High number of failed login attempts"

    condition_threshold {
      filter          = "resource.type=\"gce_instance\" AND jsonPayload.event_subtype=\"login_failure\""
      duration        = "300s"
      comparison      = "COMPARISON_GT"
      threshold_value = 5

      aggregations {
        alignment_period   = "300s"
        per_series_aligner = "ALIGN_COUNT"
      }
    }
  }

  notification_channels = [google_monitoring_notification_channel.email_alerts[0].id]

  documentation {
    content = "Alert triggered when multiple failed login attempts are detected. Possible brute force attack."
  }
}

resource "google_monitoring_alert_policy" "root_activity" {
  count = var.enable_monitoring ? 1 : 0

  display_name = "Root/Admin Activity"
  combiner     = "OR"

  conditions {
    display_name = "Root or administrative activity detected"

    condition_threshold {
      filter          = "protoPayload.authenticationInfo.principalEmail=\"root@${var.project_id}.iam.gserviceaccount.com\" OR protoPayload.authenticationInfo.principalEmail=~\"admin@.*\""
      duration        = "0s"
      comparison      = "COMPARISON_GT"
      threshold_value = 0

      aggregations {
        alignment_period   = "60s"
        per_series_aligner = "ALIGN_COUNT"
      }
    }
  }

  notification_channels = [google_monitoring_notification_channel.email_alerts[0].id]

  documentation {
    content = "Alert triggered when root or admin accounts are used. Review for unauthorized access."
  }
}

# Secret Manager for sensitive data
resource "google_secret_manager_secret" "database_password" {
  secret_id = "${local.resource_prefix}-db-password"

  replication {
    auto {
      customer_managed_encryption {
        kms_key_name = google_kms_crypto_key.security_key.id
      }
    }
  }

  labels = local.common_labels

  depends_on = [time_sleep.wait_for_apis]
}

resource "google_secret_manager_secret_version" "db_password_version" {
  secret      = google_secret_manager_secret.database_password.id
  secret_data = random_password.db_password.result
}

# Grant access to secret
resource "google_secret_manager_secret_iam_member" "secret_access" {
  secret_id = google_secret_manager_secret.database_password.secret_id
  role      = "roles/secretmanager.secretAccessor"
  member    = "serviceAccount:${google_service_account.security_ops.email}"
# member  = "group:{emailid}" if you decide to re-use this code for a prod environment
}

# Network Security - VPC with security-focused configuration
resource "google_compute_network" "secure_vpc" {
  name                    = "${local.resource_prefix}-secure-vpc"
  auto_create_subnetworks = false
  mtu                     = 1460

  depends_on = [time_sleep.wait_for_apis]
}

resource "google_compute_subnetwork" "secure_subnet" {
  name          = "${local.resource_prefix}-secure-subnet"
  ip_cidr_range = var.vpc_cidr
  region        = var.region
  network       = google_compute_network.secure_vpc.id

  private_ip_google_access = true

  dynamic "log_config" {
    for_each = var.enable_flow_logs ? [1] : []
    content {
      aggregation_interval = "INTERVAL_10_MIN"
      flow_sampling        = 0.5
      metadata             = "INCLUDE_ALL_METADATA"
    }
  }

  secondary_ip_range {
    range_name    = "pods"
    ip_cidr_range = "192.168.0.0/18"
  }

  secondary_ip_range {
    range_name    = "services"
    ip_cidr_range = "192.168.64.0/18"
  }
}

# Cloud Router and NAT for secure outbound access
resource "google_compute_router" "secure_router" {
  name    = "${local.resource_prefix}-secure-router"
  region  = var.region
  network = google_compute_network.secure_vpc.id
}

resource "google_compute_router_nat" "secure_nat" {
  name                               = "${local.resource_prefix}-secure-nat"
  router                             = google_compute_router.secure_router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

# Firewall rules with security hardening
resource "google_compute_firewall" "deny_all_ingress" {
  name    = "${local.resource_prefix}-deny-all-ingress"
  network = google_compute_network.secure_vpc.name

  deny {
    protocol = "all"
  }

  direction     = "INGRESS"
  priority      = 65534
  source_ranges = ["0.0.0.0/0"]

  log_config {
    metadata = "INCLUDE_ALL_METADATA"
  }
}

resource "google_compute_firewall" "allow_ssh_iap" {
  name    = "${local.resource_prefix}-allow-ssh-iap"
  network = google_compute_network.secure_vpc.name

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  direction     = "INGRESS"
  priority      = 1000
  source_ranges = ["35.235.240.0/20"] # IAP source range
  target_tags   = ["allow-ssh-iap"]

  log_config {
    metadata = "INCLUDE_ALL_METADATA"
  }
}

resource "google_compute_firewall" "allow_internal" {
  name    = "${local.resource_prefix}-allow-internal"
  network = google_compute_network.secure_vpc.name

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "icmp"
  }

  direction     = "INGRESS"
  priority      = 1000
  source_ranges = [var.vpc_cidr, "192.168.0.0/18", "192.168.64.0/18"]
}

resource "google_compute_firewall" "allow_health_checks" {
  name    = "${local.resource_prefix}-allow-health-checks"
  network = google_compute_network.secure_vpc.name

  allow {
    protocol = "tcp"
  }

  direction     = "INGRESS"
  priority      = 1000
  source_ranges = ["130.211.0.0/22", "35.191.0.0/16"]
  target_tags   = ["allow-health-checks"]
}

# Security-hardened VM template
resource "google_compute_instance_template" "secure_template" {
  name_prefix  = "${local.resource_prefix}-secure-"
  machine_type = "e2-micro"
  region       = var.region

  disk {
    source_image = "projects/ubuntu-os-cloud/global/images/family/ubuntu-2204-lts"
    auto_delete  = true
    boot         = true
    disk_size_gb = 20
    disk_type    = "pd-ssd"
    disk_encryption_key {
      kms_key_self_link = google_kms_crypto_key.security_key.id
    }
  }

  network_interface {
    subnetwork = google_compute_subnetwork.secure_subnet.id
    # No external IP - use IAP for access
  }

  metadata = {
    enable-oslogin                = var.enable_oslogin ? "TRUE" : "FALSE"
    block-project-ssh-keys        = "TRUE"
    enable-oslogin-2fa           = var.enable_oslogin ? "TRUE" : "FALSE"
    startup-script               = templatefile("${path.module}/startup-script.sh", {
      project_id = var.project_id
    })
  }

  tags = ["allow-ssh-iap", "secure-instance"]

  service_account {
    email  = google_service_account.security_ops.email
    scopes = ["https://www.googleapis.com/auth/cloud-platform"]
  }

  shielded_instance_config {
    enable_secure_boot          = true
    enable_vtpm                 = true
    enable_integrity_monitoring = true
  }

  labels = local.common_labels

  lifecycle {
    create_before_destroy = true
  }
}

# Binary Authorization policy for container security (conditional)
resource "google_binary_authorization_policy" "security_policy" {
  count = var.enable_binary_auth ? 1 : 0

  admission_whitelist_patterns {
    name_pattern = "gcr.io/${var.project_id}/*"
  }

  admission_whitelist_patterns {
    name_pattern = "us-docker.pkg.dev/${var.project_id}/*"
  }

  default_admission_rule {
    evaluation_mode  = "REQUIRE_ATTESTATION"
    enforcement_mode = "ENFORCED_BLOCK_AND_AUDIT_LOG"

    require_attestations_by = [
      google_binary_authorization_attestor.security_attestor[0].name
    ]
  }

  global_policy_evaluation_mode = "ENABLE"

  depends_on = [time_sleep.wait_for_apis]
}

resource "google_binary_authorization_attestor" "security_attestor" {
  count = var.enable_binary_auth ? 1 : 0

  name = "${local.resource_prefix}-security-attestor"

  attestation_authority_note {
    note_reference = google_container_analysis_note.security_note[0].name

    public_keys {
      ascii_armored_pgp_public_key = file("${path.module}/attestor-public-key.pgp")
      id                           = "${local.resource_prefix}-security-attestor-key"
    }
  }

  depends_on = [time_sleep.wait_for_apis]
}

resource "google_container_analysis_note" "security_note" {
  count = var.enable_binary_auth ? 1 : 0

  name = "${local.resource_prefix}-security-note"

  attestation_authority {
    hint {
      human_readable_name = "${var.company_name} Security Attestor"
    }
  }

  depends_on = [time_sleep.wait_for_apis]
}

# Organization policies for security hardening
resource "google_org_policy_policy" "require_shielded_vm" {
  count = var.organization_id != "" ? 1 : 0

  name   = "projects/${var.project_id}/policies/compute.requireShieldedVm"
  parent = "projects/${var.project_id}"

  spec {
    rules {
      enforce = "TRUE"
    }
  }

  depends_on = [time_sleep.wait_for_apis]
}

resource "google_org_policy_policy" "disable_serial_port" {
  count = var.organization_id != "" ? 1 : 0

  name   = "projects/${var.project_id}/policies/compute.disableSerialPortAccess"
  parent = "projects/${var.project_id}"

  spec {
    rules {
      enforce = "TRUE"
    }
  }

  depends_on = [time_sleep.wait_for_apis]
}

# Outputs with comprehensive information
output "security_service_account_email" {
  description = "Security operations service account email"
  value       = google_service_account.security_ops.email
}

output "kms_key_id" {
  description = "KMS key ID for encryption"
  value       = google_kms_crypto_key.security_key.id
}

output "kms_key_ring_id" {
  description = "KMS key ring ID"
  value       = google_kms_key_ring.security_keyring.id
}

output "security_logs_bucket" {
  description = "Security logs storage bucket"
  value       = var.enable_logging ? google_storage_bucket.security_logs[0].name : "Not created (logging disabled)"
}

output "vpc_network_id" {
  description = "Secure VPC network ID"
  value       = google_compute_network.secure_vpc.id
}

output "vpc_network_name" {
  description = "Secure VPC network name"
  value       = google_compute_network.secure_vpc.name
}

output "subnet_id" {
  description = "Secure subnet ID"
  value       = google_compute_subnetwork.secure_subnet.id
}

output "subnet_name" {
  description = "Secure subnet name"
  value       = google_compute_subnetwork.secure_subnet.name
}

output "secret_manager_secret_id" {
  description = "Secret Manager secret ID"
  value       = google_secret_manager_secret.database_password.secret_id
}

output "instance_template_id" {
  description = "Security-hardened instance template ID"
  value       = google_compute_instance_template.secure_template.id
}

output "custom_role_id" {
  description = "Custom security role ID"
  value       = google_project_iam_custom_role.security_admin.id
}

output "monitoring_notification_channel" {
  description = "Monitoring notification channel ID"
  value       = var.enable_monitoring ? google_monitoring_notification_channel.email_alerts[0].id : "Not created (monitoring disabled)"
}

output "feature_status" {
  description = "Status of optional security features"
  value = {
    security_center_enabled = var.enable_security_center
    binary_auth_enabled     = var.enable_binary_auth
    monitoring_enabled      = var.enable_monitoring
    logging_enabled         = var.enable_logging
    flow_logs_enabled      = var.enable_flow_logs
    oslogin_enabled        = var.enable_oslogin
  }
}

output "estimated_monthly_cost" {
  description = "Estimated monthly cost breakdown"
  value = {
    kms_key       = "$1.00"
    secret_manager = "$0.06 per secret"
    storage       = "$0.02 per GB (logs)"
    monitoring    = "Free tier available"
    security_center = var.enable_security_center ? "$1000+ (premium)" : "Not enabled"
    flow_logs     = var.enable_flow_logs ? "$0.50 per GB" : "Not enabled"
  }
}
